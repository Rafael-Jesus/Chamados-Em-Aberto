(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (factory((global.reactCollect = {}),global.React));
}(this, (function (exports,React) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  //. # React Collect

  var Component = React.Component;
  var createElement = React.createElement;
  var Context = React.createContext ();

  // identity :: a -> a
  function identity(x) {
    return x;
  }

  // getComponentName :: ReactComponent? -> String
  function getComponentName(Component) {
    return Component == null ?
           '<Null>' :
           (Component.displayName || Component.name || '<Anonymous>');
  }

  function createBaseCollectionManager(item) {

    function BaseComponent(props) {
      Component.call (this, props);
      props.collect (item);
    }

    BaseComponent.prototype = Object.create (Component.prototype);

    BaseComponent.prototype.componentWillUnmount = function() {
      this.props.uncollect (item);
    };

    return BaseComponent;

  }

  //. ## API
  //.
  //# collect :: Any? -> ReactComponent -> ReactComponent
  //.
  //. Decorates a component with collection capabilities. Decorated components
  //. must have a [`Collector`](#Collector) as one of their ancestors.
  //.
  //. When given, the first argument is an item that is always automatically
  //. collected whenever the component mounts, and uncollected when the component
  //. unmounts.
  //.
  //. Alternatively, for more control, you can manually use the `collect` and
  //. `uncollect` functions that are given to the decorated component as props.
  //.
  //. ```js
  //. import {collect} from 'react-collect';
  //. import {MyComponent} from './my-component';
  //.
  //. export default collect ({message: 'Hello!'}) (MyComponent);
  //. ```
  function collect(item) {

    var BaseComponent = (item == null) ?
                        (Component) :
                        (createBaseCollectionManager (item));

    return function(UserComponent) {

      var name = getComponentName (UserComponent);

      function CollectorManager(props) {
        BaseComponent.call (this, props);
      }

      CollectorManager.prototype = Object.create (BaseComponent.prototype);

      CollectorManager.prototype.render = function() {
        return UserComponent && createElement (UserComponent, this.props);
      };

      CollectorManager.displayName = 'CollectorManager(' + name + ')';

      function Collecting(xs) {
        return createElement (Context.Consumer, {}, function(ys) {
          return createElement (CollectorManager, Object.assign ({}, xs, ys));
        });
      }

      Collecting.displayName = 'Collecting(' + name + ')';

      return Collecting;

    };
  }

  //# Collector :: ReactComponent
  //.
  //. This component wraps your tree and collects the items from all child
  //. components that have been decorated with [`collect`](#collect).
  //.
  //. Expects a single property `onChange` - the function to call when the
  //. collection has changed. The function is called with an array of distinct
  //. entries.
  //.
  //. ```jsx
  //. import {Collector} from 'react-collect';
  //. import App from './my-app';
  //.
  //. const onChange = collection => collection.forEach (() => { /* */ });
  //.
  //. export default <Collector onChange={onChange}><App /></Collector>;
  //. ```
  function Collector(props) {
    if (typeof props.onChange !== 'function') {
      throw new TypeError ('Collector wants an onChange prop of type function');
    }
    Component.call (this, props);
    this.toCollect = new Set ();
    this.toUncollect = new Set ();
    this.collection = new Set ();
  }

  Collector.prototype = Object.create (Component.prototype);

  Collector.prototype.updateCollection = function() {
    var toCollect = Array.from (this.toCollect).filter (function(item) {
      return !(this.toUncollect.has (item) || this.collection.has (item));
    }, this);
    var toUncollect = Array.from (this.toUncollect).filter (function(item) {
      return !this.toCollect.has (item) && this.collection.has (item);
    }, this);
    this.toCollect = new Set ();
    this.toUncollect = new Set ();
    if (toCollect.length === 0 && toUncollect.length === 0) {
      return;
    }
    toUncollect.forEach (this.collection.delete, this.collection);
    toCollect.forEach (this.collection.add, this.collection);
    this.props.onChange (Array.from (this.collection));
  };

  Collector.prototype.setDirty = function() {
    clearTimeout (this.timeoutId);
    this.timeoutId = setTimeout (function(collector) {
      collector.updateCollection ();
    }, 20, this);
  };

  Collector.prototype.collect = function(item) {
    this.toCollect.add (item);
    this.setDirty ();
  };

  Collector.prototype.uncollect = function(item) {
    this.toUncollect.add (item);
    this.setDirty ();
  };

  Collector.prototype.componentWillUnmount = function() {
    clearTimeout (this.timeoutId);
    if (this.collection.size > 0) {
      this.props.onChange ([]);
    }
  };

  Collector.prototype.render = function() {
    return createElement (
      Context.Provider,
      {value: {
        collect: this.collect.bind (this),
        uncollect: this.uncollect.bind (this)
      }},
      this.props.children
    );
  };

  exports.identity = identity;
  exports.getComponentName = getComponentName;
  exports.createBaseCollectionManager = createBaseCollectionManager;
  exports.collect = collect;
  exports.Collector = Collector;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
